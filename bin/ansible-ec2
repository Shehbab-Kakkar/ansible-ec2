#!/usr/bin/env python

import argparse
import sys
from datetime import datetime
import dateutil.parser
from subprocess import call
from ansible import inventory
from ansible import constants

class AnsibleEc2Cli(object):
    def __init__(self):
        ''' Main execution path '''
        
        self.parse_cli_args()
        print self.args
        self.args.func()
    
    
    def parse_cli_args(self):
        ''' Command line argument processing '''
        
        # Top level parser
        self.parser = argparse.ArgumentParser(description='AWS EC2 helpers, utilities and tricks built on top of Ansible')
        
        # Options common to all commands
        self.common_parser = argparse.ArgumentParser(add_help=False)
        self.common_parser.add_argument('-i', '--inventory-file', metavar='INVENTORY',
                action='store', help='The inventory file to use (default=/etc/ansible/hosts)')
        self.common_parser.add_argument('-ic', action='store_true', default=False,
                help='Ignore case - perform case insensitive matches on the filters')
        self.common_parser.add_argument('-v', '--verbose', action='count',
                help='Verbose output useful for debugging, can be use multiple times for more verbose output')
        
        # Filtering
        filters = self.common_parser.add_argument_group('Filters', 'Reduce the number of instances by filtering on various fields. Filters can be used in combination with each other, and only instances that appear in all filtered sets are returned. If no filters are used, all instances are returned in all regions.')
        filters.add_argument('--name', action='store', help='The "Name" tag of the instance/s to filter on. E.g. --name=Server1')
        filters.add_argument('--sg', metavar='SECURITY_GROUP', action='store', help='Return only instances in a specific security group. E.g. --sg=default')
        filters.add_argument('--key', metavar='KEY_PAIR', action='store', help='The name of the key pair to filter on. E.g. --key=superadmin')
        filters.add_argument('--region', action='store', help='Limit to only one region. E.g. --region=us-east-1')
        filters.add_argument('--zone', metavar='AVAILABILITY_ZONE', action='store', help='Limit to only one availability zone. E.g. --zone=us-east-1a')
        filters.add_argument('raw_group', metavar='GROUP_NAME', nargs='?', help='The raw group name to filter on based on the groups produced by the Inventory. This can also be the Instance ID. E.g. i-abcd1234')
        
        self.subparsers = self.parser.add_subparsers(title='Commands')
        self.command_parsers = {}
        
        # Create the parser for the "help" command
        help_parser = self.add_command('help', 'Get help about a command', add_common=False)
        help_parser.add_argument('help_command', metavar='command', nargs='*', help='The command to get help on')
        
        # Create the parser for the "list" command
        list_parser = self.add_command('list', 'Get a list of instances/groups')
        
        # Create the parser for the "info" command
        info_parser = self.add_command('info', 'Get information about a specific instance')
        
        # Create the parser for the "ssh" command
        ssh_parser = self.add_command('ssh', 'Open an SSH connection to a specific instance')
        ssh_parser.add_argument('--private-key', metavar='PRIVATE_KEY_FILE', action='store', help='Use this file to authenticate the connection')
        ssh_parser.add_argument('-u', '--user', metavar='REMOTE_USER', action='store', help='Connect as this user')
        
        # Final step - go parse those args
        self.args = self.parser.parse_args()
    
    
    def add_command(self, command, help, add_common=True):
        ''' Adds a command to the list of available commands, and returns a
        parser that can be used to add arguments specific to that command '''
        
        if add_common:
            self.command_parsers[command] = self.subparsers.add_parser(command, help=help,
                                                                       parents=[self.common_parser])
        else:
            self.command_parsers[command] = self.subparsers.add_parser(command, help=help)
        
        self.command_parsers[command].set_defaults(func=getattr(self, command))
        
        return self.command_parsers[command]
    
    
    def get_groups(self):
        ''' Gets a list of all groups '''
        
        print 'Reading inventory...'
        self.inventory_manager = inventory.Inventory(constants.DEFAULT_HOST_LIST)
        groups = self.inventory_manager.get_groups()
        if len(groups) == 0:
            print >>sys.stderr, 'ERROR: No instance groups found - check inventory'
            sys.exit(1)
        
        if self.args.verbose > 0:
            print 'Inventory produced %d groups' % len(groups)
        
        return groups
    
    
    def get_group_by_name(self, name):
        ''' Gets an instance group by it's tag Name '''
        
        pattern = 'tag_Name_%s' % self.args.name
        instance_group = None
        for group in self.get_groups():
            if group.name == pattern:
                instance_group = group
                break;
        
        if instance_group == None:
            print >>sys.stderr, 'ERROR: No instance group matched the given name'
            sys.exit(1)
        
        return instance_group
    
    
    def help(self):
        ''' Command specific help '''
        
        if 'help_command' in self.args:
            if len(self.args.help_command) == 0:
                self.parser.print_help()
            else:
                cmd = self.args.help_command[0]
                if cmd in self.command_parsers:
                    self.command_parsers[cmd].print_help()
                else:
                    print >>sys.stderr, 'ERROR: Unknown command: %s' % self.args.help_command[0]
                    sys.exit(1)
    
    
    def list(self):
        ''' Gets a list of instances '''
        
        group_names = []
        for group in self.get_groups():
            group_names.append(group.name)
        
        group_names.sort()
        for name in group_names:
            print name 
    
    
    def ssh(self):
        if 'name' in self.args and not self.args.name == None:
            instance_group = self.get_group_by_name(self.args.name)
            hosts = instance_group.get_hosts();
            if len(hosts) != 1:
                print >>sys.stderr, 'ERROR: %s matches more than one instance' % pattern
                for h in hosts:
                    print '  - ' + h.name
                sys.exit(1)
            host = hosts[0]
            
            cmd = 'ssh %s' % host.name
            
            print cmd
            try:
                retcode = call(cmd, shell=True)
                if retcode < 0:
                    print 'Child was terminated by signal', -retcode
                else:
                    print 'Child returned', retcode
            except OSError as e:
                print 'Execution failed:', e
        else:
            print 'oops: Not implemented yet'
    
    
    def info(self):
        print self.args
        if 'name' in self.args and not self.args.name == None:
            instance_group = self.get_group_by_name(self.args.name)
            i = 1
            now = datetime.utcnow()
            for host in instance_group.get_hosts():
                info = self.inventory_manager.get_variables(host.name)
                
                # Do date/time calculations
                launch = dateutil.parser.parse(info['ec2_launch_time']).replace(tzinfo=None)
                uptime = now - launch
                
                # We have all the data, go print
                print '%d: %s' % (i, info['ec2_tag_Name'])
                print '  Instance: %-15s      AMI: %-15s  Kernel: %s' % (info['ec2_id'], info['ec2_image_id'], info['ec2_kernel'])
                print '      Type: %-15s     Arch: %-15s   State: %s' % (info['ec2_instance_type'], info['ec2_architecture'], info['ec2_state'])
                print '      Zone: %-15s Key Pair: %s' % (info['ec2_placement'], info['ec2_key_name'])
                print '  Launch Time: %s' % info['ec2_launch_time']
                print '      Up Time: %d days, %d hours' % (uptime.days, (uptime.seconds/3600))
                print '   Public DNS: %s' % info['ec2_public_dns_name']
                print '    Public IP: %s' % info['ec2_ip_address']
                print '  Private DNS: %s' % info['ec2_private_dns_name']
                print '   Private IP: %s' % info['ec2_private_ip_address']
                if info['ec2_vpc_id']:
                    print '  VPC: %s    Subnet: %s' % (info['ec2_vpc_id'], info['ec2_subnet_id'])
                print '  Security Groups: %s' % info['ec2_security_group_names']
                print ''
                i = i+1
                '''
                ec2_security_group_ids: sg-6021bd08
                ec2_security_group_names: dmp-0725-InstanceSecurityGroup-1XTZBSCMP1BZB
                group_names: [u'i-b6c8f3ce', u'security_group_dmp-0725-InstanceSecurityGroup-1XTZBSCMP1BZB', u'tag_Name_DMP', u'tag_aws_autoscaling_groupName_dmp-0725-DMPServerGroup-144PQWYTP9X94', u'tag_aws_cloudformation_logical-id_DMPServerGroup', u'tag_aws_cloudformation_stack-id_arn_aws_cloudformation_us-east-1_313895386618_stack_dmp-0725_0d723e40-d689-11e1-b4af-506cfa68b825', u'tag_aws_cloudformation_stack-name_dmp-0725', u'us-east-1', u'us-east-1c']
                '''
        
        else:
            print 'oops: Not implemented yet'


########################################################

if __name__ == '__main__':
    cli = AnsibleEc2Cli()


#!/usr/bin/env python

import argparse
import sys
from datetime import datetime
import dateutil.parser
from subprocess import call
from ansible import inventory
from ansible import constants

class AnsibleEc2Cli(object):
    def __init__(self):
        ''' Main execution path '''
        
        self.parse_cli_args()
        self.args.func()
    
    
    def parse_cli_args(self):
        ''' Command line argument processing '''
        
        # Top level parser
        parser = argparse.ArgumentParser(description='AWS EC2 helpers, utilities and tricks built on top of Ansible')
        
        # Options common to all commands
        self.common_parser = argparse.ArgumentParser(add_help=False)
        self.common_parser.add_argument('-v', '--verbose', action='count',
                           help='Verbose output useful for debugging, can be use multiple times for more verbose output')
        
        self.subparsers = parser.add_subparsers(title='Commands')
        self.command_parsers = {}
        
        # Create the parser for the "help" command
        help_parser = self.add_command('help', 'Get help about a command', add_common=False)
        help_parser.add_argument('help_command', metavar='command', nargs='*', help='The command to get help on')

        # Create the parser for the "info" command
        info_parser = self.add_command('info', 'Get information about a specific instance')
        info_parser.add_argument('--name', action='store', help='The "Name" tag of the instance/s to get info on')
        
        # Create the parser for the "ssh" command
        ssh_parser = self.add_command('ssh', 'Open an SSH connection to a specific instance')
        ssh_parser.add_argument('--name', action='store', help='The "Name" tag of the instance to SSH to')
        
        # Final step - go parse those args
        self.parser = parser
        self.args = self.parser.parse_args()
    
    
    def add_command(self, command, help, add_common=True):
        ''' Adds a command to the list of available commands, and returns a
        parser that can be used to add arguments specific to that command '''
        
        if add_common:
            self.command_parsers[command] = self.subparsers.add_parser(command, help=help,
                                                                       parents=[self.common_parser])
        else:
            self.command_parsers[command] = self.subparsers.add_parser(command, help=help)
        
        self.command_parsers[command].set_defaults(func=getattr(self, command))
        
        return self.command_parsers[command]
    
    
    def get_group_by_name(self, name):
        ''' Gets an instance group by it's tag Name '''
        
        self.inventory_manager = inventory.Inventory(constants.DEFAULT_HOST_LIST)
        groups = self.inventory_manager.get_groups()
        if len(groups) == 0:
            print >>sys.stderr, 'ERROR: No instance groups found - check inventory'
            sys.exit(1)
        
        pattern = 'tag_Name_%s' % self.args.name
        instance_group = None
        for group in groups:
            if group.name == pattern:
                instance_group = group
                break;
        
        if instance_group == None:
            print >>sys.stderr, 'ERROR: No instance group matched the given name'
            sys.exit(1)
        
        return instance_group
    
    
    def help(self):
        ''' Command specific help '''
        
        if 'help_command' in self.args:
            if len(self.args.help_command) == 0:
                self.parser.print_help()
            else:
                cmd = self.args.help_command[0]
                if cmd in self.command_parsers:
                    self.command_parsers[cmd].print_help()
                else:
                    print 'Error: Unknown command: %s' % self.args.help_command[0]
                    sys.exit(1)
    
    
    def ssh(self):
        if 'name' in self.args:
            instance_group = self.get_group_by_name(self.args.name)
            hosts = instance_group.get_hosts();
            if len(hosts) != 1:
                print 'ERROR: %s matches more than one instance' % pattern
                for h in hosts:
                    print '  - ' + h.name
                sys.exit(1)
            host = hosts[0]
            
            cmd = 'ssh %s' % host.name
            
            print cmd
            try:
                retcode = call(cmd, shell=True)
                if retcode < 0:
                    print 'Child was terminated by signal', -retcode
                else:
                    print 'Child returned', retcode
            except OSError as e:
                print 'Execution failed:', e
        else:
            print 'oops: Not implemented yet'
    
    
    def info(self):
        if 'name' in self.args:
            instance_group = self.get_group_by_name(self.args.name)
            i = 1
            now = datetime.utcnow()
            for host in instance_group.get_hosts():
                info = self.inventory_manager.get_variables(host.name)
                
                # Do date/time calculations
                launch = dateutil.parser.parse(info['ec2_launch_time']).replace(tzinfo=None)
                uptime = now - launch
                
                # We have all the data, go print
                print '%d: %s' % (i, info['ec2_tag_Name'])
                print '  Instance: %-15s      AMI: %-15s  Kernel: %s' % (info['ec2_id'], info['ec2_image_id'], info['ec2_kernel'])
                print '      Type: %-15s     Arch: %-15s   State: %s' % (info['ec2_instance_type'], info['ec2_architecture'], info['ec2_state'])
                print '      Zone: %-15s Key Pair: %s' % (info['ec2_placement'], info['ec2_key_name'])
                print '  Launch Time: %s' % info['ec2_launch_time']
                print '      Up Time: %d days, %d hours' % (uptime.days, (uptime.seconds/3600))
                print '   Public DNS: %s' % info['ec2_public_dns_name']
                print '    Public IP: %s' % info['ec2_ip_address']
                print '  Private DNS: %s' % info['ec2_private_dns_name']
                print '   Private IP: %s' % info['ec2_private_ip_address']
                if info['ec2_vpc_id']:
                    print '  VPC: %s    Subnet: %s' % (info['ec2_vpc_id'], info['ec2_subnet_id'])
                print '  Security Groups: %s' % info['ec2_security_group_names']
                print ''
                i = i+1
                '''
                ec2_security_group_ids: sg-6021bd08
                ec2_security_group_names: dmp-0725-InstanceSecurityGroup-1XTZBSCMP1BZB
                group_names: [u'i-b6c8f3ce', u'security_group_dmp-0725-InstanceSecurityGroup-1XTZBSCMP1BZB', u'tag_Name_DMP', u'tag_aws_autoscaling_groupName_dmp-0725-DMPServerGroup-144PQWYTP9X94', u'tag_aws_cloudformation_logical-id_DMPServerGroup', u'tag_aws_cloudformation_stack-id_arn_aws_cloudformation_us-east-1_313895386618_stack_dmp-0725_0d723e40-d689-11e1-b4af-506cfa68b825', u'tag_aws_cloudformation_stack-name_dmp-0725', u'us-east-1', u'us-east-1c']
                '''
        
        else:
            print 'oops: Not implemented yet'
    

########################################################

if __name__ == '__main__':
    cli = AnsibleEc2Cli()

